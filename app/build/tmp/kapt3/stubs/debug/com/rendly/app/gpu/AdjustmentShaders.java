package com.rendly.app.gpu;

/**
 * Shaders GLSL profesionales para ajustes de imagen nivel Instagram/Lightroom
 * Pipeline de color en espacio lineal con conversi√≥n sRGB correcta
 * Optimizado para 60+ FPS en tiempo real
 */
@kotlin.Metadata(mv = {1, 9, 0}, k = 1, xi = 48, d1 = {"\u0000\u0014\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\n\u0002\u0010\u000e\n\u0002\b\u0004\b\u00c6\u0002\u0018\u00002\u00020\u0001:\u0002\u0006\u0007B\u0007\b\u0002\u00a2\u0006\u0002\u0010\u0002R\u000e\u0010\u0003\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0005\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000\u00a8\u0006\b"}, d2 = {"Lcom/rendly/app/gpu/AdjustmentShaders;", "", "()V", "FRAGMENT_SHADER", "", "VERTEX_SHADER", "Attributes", "Uniforms", "app_debug"})
public final class AdjustmentShaders {
    @org.jetbrains.annotations.NotNull
    public static final java.lang.String VERTEX_SHADER = "\n        attribute vec4 aPosition;\n        attribute vec2 aTexCoord;\n        varying vec2 vTexCoord;\n        \n        void main() {\n            gl_Position = aPosition;\n            vTexCoord = aTexCoord;\n        }\n    ";
    @org.jetbrains.annotations.NotNull
    public static final java.lang.String FRAGMENT_SHADER = "\n        precision highp float;\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D uTexture;\n        \n        // Par\u00e1metros de ajuste (uniforms para cambio instant\u00e1neo)\n        uniform float uBrightness;    // -1.0 a 1.0\n        uniform float uContrast;      // -1.0 a 1.0\n        uniform float uSaturation;    // -1.0 a 1.0\n        uniform float uExposure;      // -2.0 a 2.0\n        uniform float uHighlights;    // -1.0 a 1.0\n        uniform float uShadows;       // -1.0 a 1.0\n        uniform float uTemperature;   // -1.0 a 1.0\n        uniform float uTint;          // -1.0 a 1.0\n        uniform float uGrain;         // 0.0 a 1.0\n        uniform float uTime;          // Para grain estable\n        uniform vec2 uResolution;     // Para grain dependiente de posici\u00f3n\n        \n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        // CONVERSI\u00d3N sRGB \u2194 LINEAR (cr\u00edtico para calidad fotogr\u00e1fica)\n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        vec3 srgbToLinear(vec3 srgb) {\n            vec3 low = srgb / 12.92;\n            vec3 high = pow((srgb + 0.055) / 1.055, vec3(2.4));\n            return mix(low, high, step(vec3(0.04045), srgb));\n        }\n        \n        vec3 linearToSrgb(vec3 linear) {\n            vec3 low = linear * 12.92;\n            vec3 high = 1.055 * pow(linear, vec3(1.0/2.4)) - 0.055;\n            return mix(low, high, step(vec3(0.0031308), linear));\n        }\n        \n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        // LUMINANCIA PERCEPTUAL (Rec. 709)\n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        float getLuminance(vec3 color) {\n            return dot(color, vec3(0.2126, 0.7152, 0.0722));\n        }\n        \n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        // CURVA S PARA CONTRASTE (m\u00e1s natural que lineal)\n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        float sCurve(float x, float contrast) {\n            float midpoint = 0.5;\n            float slope = 1.0 + contrast * 2.0;\n            \n            if (x < midpoint) {\n                return midpoint * pow(x / midpoint, slope);\n            } else {\n                return 1.0 - (1.0 - midpoint) * pow((1.0 - x) / (1.0 - midpoint), slope);\n            }\n        }\n        \n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        // HIGHLIGHTS & SHADOWS (control independiente - nivel PRO)\n        // Curvas adaptativas con protecci\u00f3n de detalle\n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        vec3 applyHighlightsShadows(vec3 color, float highlights, float shadows) {\n            float lum = getLuminance(color);\n            \n            // M\u00e1scaras suaves con curvas m\u00e1s naturales\n            float highlightMask = smoothstep(0.35, 0.85, lum);\n            float shadowMask = 1.0 - smoothstep(0.15, 0.65, lum);\n            \n            // Highlight recovery: compresi\u00f3n suave de highlights\n            if (highlights < 0.0) {\n                float recovery = -highlights * highlightMask;\n                color = mix(color, color * (1.0 - recovery * 0.4), highlightMask);\n            } else {\n                color += color * highlights * highlightMask * 0.3;\n            }\n            \n            // Shadow lift: recuperaci\u00f3n de sombras con preservaci\u00f3n de detalle\n            if (shadows > 0.0) {\n                float lift = shadows * shadowMask * 0.4;\n                color = color + (1.0 - color) * lift * shadowMask;\n            } else {\n                color *= 1.0 + shadows * shadowMask * 0.5;\n            }\n            \n            return color;\n        }\n        \n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        // FILMIC TONE MAPPING (roll-off suave en highlights)\n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        vec3 filmicTonemap(vec3 color) {\n            // ACES-inspired filmic curve simplificada\n            float a = 2.51;\n            float b = 0.03;\n            float c = 2.43;\n            float d = 0.59;\n            float e = 0.14;\n            return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\n        }\n        \n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        // TEMPERATURA Y TINTE (balance de blancos)\n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        vec3 applyTemperatureTint(vec3 color, float temperature, float tint) {\n            // Temperatura: c\u00e1lido (amarillo/naranja) \u2194 fr\u00edo (azul)\n            color.r += temperature * 0.1;\n            color.b -= temperature * 0.1;\n            \n            // Tinte: verde \u2194 magenta\n            color.g += tint * 0.05;\n            color.r -= tint * 0.025;\n            color.b -= tint * 0.025;\n            \n            return color;\n        }\n        \n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        // SATURACI\u00d3N PERCEPTUAL (no RGB directo)\n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        vec3 applySaturation(vec3 color, float saturation) {\n            float lum = getLuminance(color);\n            vec3 grey = vec3(lum);\n            return mix(grey, color, 1.0 + saturation);\n        }\n        \n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        // GRAIN FOTOGR\u00c1FICO PROFESIONAL\n        // - Dependiente de luminancia (m\u00e1s en sombras, menos en highlights)\n        // - Hash-based para estabilidad\n        // - Blue noise pattern para aspecto natural\n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        float hash(vec2 p) {\n            vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n            p3 += dot(p3, p3.yzx + 33.33);\n            return fract((p3.x + p3.y) * p3.z);\n        }\n        \n        float blueNoise(vec2 uv) {\n            // Aproximaci\u00f3n de blue noise con hash multicapa\n            float n = hash(uv * 1.0);\n            n += hash(uv * 2.0) * 0.5;\n            n += hash(uv * 4.0) * 0.25;\n            return (n / 1.75) * 2.0 - 1.0;\n        }\n        \n        vec3 applyGrain(vec3 color, vec2 uv, float grain) {\n            if (grain < 0.001) return color;\n            \n            float lum = getLuminance(color);\n            \n            // Grain m\u00e1s fuerte en sombras, casi invisible en highlights\n            float grainStrength = grain * 0.15 * (1.0 - lum * 0.7);\n            \n            // Noise estable basado en posici\u00f3n (no cambia con el tiempo)\n            float noise = blueNoise(uv * uResolution);\n            \n            // Aplicar grain con preservaci\u00f3n de color\n            vec3 grainColor = color + vec3(noise * grainStrength);\n            \n            return grainColor;\n        }\n        \n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        // TEMPERATURA/TINTE CON APROXIMACI\u00d3N LMS (m\u00e1s preciso)\n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        vec3 applyTemperatureTintLMS(vec3 color, float temperature, float tint) {\n            // Matriz RGB a LMS (aproximaci\u00f3n Bradford)\n            mat3 rgbToLms = mat3(\n                0.4122214708, 0.5363325363, 0.0514459929,\n                0.2119034982, 0.6806995451, 0.1073969566,\n                0.0883024619, 0.2817188376, 0.6299787005\n            );\n            \n            // Matriz LMS a RGB\n            mat3 lmsToRgb = mat3(\n                4.0767416621, -3.3077115913, 0.2309699292,\n                -1.2684380046, 2.6097574011, -0.3413193965,\n                -0.0041960863, -0.7034186147, 1.7076147010\n            );\n            \n            // Convertir a LMS\n            vec3 lms = rgbToLms * color;\n            \n            // Ajustar temperatura (L/M balance)\n            float tempScale = 1.0 + temperature * 0.15;\n            lms.x *= tempScale;\n            lms.z /= tempScale;\n            \n            // Ajustar tinte (verde/magenta)\n            float tintScale = 1.0 + tint * 0.1;\n            lms.y *= tintScale;\n            \n            // Convertir de vuelta a RGB\n            return lmsToRgb * lms;\n        }\n        \n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        // SHADER PRINCIPAL - Pipeline Instagram/Lightroom\n        // Orden correcto para calidad m\u00e1xima\n        // PASS-THROUGH cuando no hay ajustes para evitar cambio de tono\n        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        void main() {\n            vec4 texColor = texture2D(uTexture, vTexCoord);\n            vec3 color = texColor.rgb;\n            \n            // Detectar si hay alg\u00fan ajuste activo\n            bool hasAdjustments = abs(uBrightness) > 0.001 || \n                                  abs(uContrast) > 0.001 || \n                                  abs(uSaturation) > 0.001 || \n                                  abs(uExposure) > 0.001 || \n                                  abs(uHighlights) > 0.001 || \n                                  abs(uShadows) > 0.001 || \n                                  abs(uTemperature) > 0.001 || \n                                  abs(uTint) > 0.001 || \n                                  uGrain > 0.001;\n            \n            // Si no hay ajustes, PASS-THROUGH directo (sin cambio de tono)\n            if (!hasAdjustments) {\n                gl_FragColor = texColor;\n                return;\n            }\n            \n            // 1. sRGB \u2192 Linear (cr\u00edtico para calidad)\n            color = srgbToLinear(color);\n            \n            // 2. Exposici\u00f3n (multiplicador EV)\n            if (abs(uExposure) > 0.001) {\n                float exposureMultiplier = pow(2.0, uExposure);\n                color *= exposureMultiplier;\n            }\n            \n            // 3. Filmic Tone Mapping solo si hay exposici\u00f3n positiva\n            // Suaviza highlights, previene clipping\n            if (uExposure > 0.1) {\n                color = filmicTonemap(color);\n            }\n            \n            // 4. Highlights & Shadows\n            if (abs(uHighlights) > 0.001 || abs(uShadows) > 0.001) {\n                color = applyHighlightsShadows(color, uHighlights, uShadows);\n            }\n            \n            // 5. Temperatura y Tinte (en espacio LMS para precisi\u00f3n)\n            if (abs(uTemperature) > 0.001 || abs(uTint) > 0.001) {\n                color = applyTemperatureTintLMS(color, uTemperature, uTint);\n            }\n            \n            // 6. Contraste con curva S\n            if (abs(uContrast) > 0.001) {\n                color.r = sCurve(clamp(color.r, 0.0, 1.0), uContrast);\n                color.g = sCurve(clamp(color.g, 0.0, 1.0), uContrast);\n                color.b = sCurve(clamp(color.b, 0.0, 1.0), uContrast);\n            }\n            \n            // 7. Brillo (gamma-aware)\n            if (abs(uBrightness) > 0.001) {\n                float brightnessFactor = 1.0 + uBrightness * 0.5;\n                color *= brightnessFactor;\n            }\n            \n            // 8. Saturaci\u00f3n perceptual\n            if (abs(uSaturation) > 0.001) {\n                color = applySaturation(color, uSaturation);\n            }\n            \n            // 9. Clamp antes de conversi\u00f3n\n            color = clamp(color, 0.0, 1.0);\n            \n            // 10. Linear \u2192 sRGB\n            color = linearToSrgb(color);\n            \n            // 11. Grain fotogr\u00e1fico (despu\u00e9s de sRGB)\n            if (uGrain > 0.001) {\n                color = applyGrain(color, vTexCoord, uGrain);\n            }\n            \n            // 12. Clamp final\n            color = clamp(color, 0.0, 1.0);\n            \n            gl_FragColor = vec4(color, texColor.a);\n        }\n    ";
    @org.jetbrains.annotations.NotNull
    public static final com.rendly.app.gpu.AdjustmentShaders INSTANCE = null;
    
    private AdjustmentShaders() {
        super();
    }
    
    @kotlin.Metadata(mv = {1, 9, 0}, k = 1, xi = 48, d1 = {"\u0000\u0014\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\n\u0002\u0010\u000e\n\u0002\b\u0002\b\u00c6\u0002\u0018\u00002\u00020\u0001B\u0007\b\u0002\u00a2\u0006\u0002\u0010\u0002R\u000e\u0010\u0003\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0005\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000\u00a8\u0006\u0006"}, d2 = {"Lcom/rendly/app/gpu/AdjustmentShaders$Attributes;", "", "()V", "POSITION", "", "TEX_COORD", "app_debug"})
    public static final class Attributes {
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String POSITION = "aPosition";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String TEX_COORD = "aTexCoord";
        @org.jetbrains.annotations.NotNull
        public static final com.rendly.app.gpu.AdjustmentShaders.Attributes INSTANCE = null;
        
        private Attributes() {
            super();
        }
    }
    
    @kotlin.Metadata(mv = {1, 9, 0}, k = 1, xi = 48, d1 = {"\u0000\u0014\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\n\u0002\u0010\u000e\n\u0002\b\f\b\u00c6\u0002\u0018\u00002\u00020\u0001B\u0007\b\u0002\u00a2\u0006\u0002\u0010\u0002R\u000e\u0010\u0003\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0005\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0006\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0007\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\b\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\t\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\n\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u000b\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\f\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\r\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u000e\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u000f\u001a\u00020\u0004X\u0086T\u00a2\u0006\u0002\n\u0000\u00a8\u0006\u0010"}, d2 = {"Lcom/rendly/app/gpu/AdjustmentShaders$Uniforms;", "", "()V", "BRIGHTNESS", "", "CONTRAST", "EXPOSURE", "GRAIN", "HIGHLIGHTS", "RESOLUTION", "SATURATION", "SHADOWS", "TEMPERATURE", "TEXTURE", "TIME", "TINT", "app_debug"})
    public static final class Uniforms {
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String TEXTURE = "uTexture";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String BRIGHTNESS = "uBrightness";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String CONTRAST = "uContrast";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String SATURATION = "uSaturation";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String EXPOSURE = "uExposure";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String HIGHLIGHTS = "uHighlights";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String SHADOWS = "uShadows";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String TEMPERATURE = "uTemperature";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String TINT = "uTint";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String GRAIN = "uGrain";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String TIME = "uTime";
        @org.jetbrains.annotations.NotNull
        public static final java.lang.String RESOLUTION = "uResolution";
        @org.jetbrains.annotations.NotNull
        public static final com.rendly.app.gpu.AdjustmentShaders.Uniforms INSTANCE = null;
        
        private Uniforms() {
            super();
        }
    }
}